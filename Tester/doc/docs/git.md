Тестер позволяет выгружать и загружать сценарии в файловую систему.

Поддерживается инкрементальная выгрузка/загрузка.

Обработки по выгрузке и загрузке доступны в меню быстрых функций, а также через акселераторы `Ctrl+Shift+B` (выгрузка), `Ctrl+Shift+L` (загрузка)

Выгруженные файлы могут быть синхронизированы с системами контроля версий, например `Git`.

Для конфигурации ERP2, было создано депо [https://github.com/grumagargler/ERP2](https://github.com/grumagargler/ERP2)

Функции выгрузки/загрузки могут быть полезны для обмена тестами или создания единых хранилищ тестов для типовых конфигураций.

## Интеграция

Под интеграцией понимается возможность Тестера реагировать на внешние запросы сервисов `github.com`, `gitlab.com` и других. В качестве примера, будет рассмотрен автоматический запуск процесса тестирования после помещения в git-репозиторий очередных изменений (т.е. запуск тестов после `push-request` в терминах `git`).

Итак, нам понадобится рабочий git-репозиторий и настроенный в нем `webhook`. В качестве примера будем использовать публичный репозиторий самого тестера [https://github.com/grumagargler/tester.edt](https://github.com/grumagargler/tester.edt) (создание `webhook`\-а для gitlab выполняется аналогично).

> Создание в `EDT` проекта, подключение его к удаленному git-репозиторию, детальная настройка github\-профиля, событий и их свойств выходит за рамки этого раздела

### Добавление webhook

Для создания `webhook`\-а нужно войти в меню `Settings / Webhooks` и добавить новую запись. Вот пример уже готовой настройки:

![](/img/2019_12_02_20_40_242.png)

На картинке, в поле `Payload URL` указан адрес, по которому github будет выполнять `post`\-запросы при помещении в репозиторий очередных изменений (состав событий и их свойства могут быть настроены на стороне github дополнительно). Доступный из-вне веб-сервис тестера должен быть в формате [https://<сайт>/<публикация>/hs/Hook](https://xn--%3C%3E-5nf6e8cm/%3C%D0%BF%D1%83%D0%B1%D0%BB%D0%B8%D0%BA%D0%B0%D1%86%D0%B8%D1%8F%3E/hs/Hook).

### Настройка сервиса Тестера

Следующий шаг – публикация сервиса на стороне тестера, так, чтобы он был доступен из-вне github\-у. Несмотря на то, что публикация со стороны платформы 1С выполняется стандартно, из конфигуратора, настройки авторизации заслуживают отдельного внимания.

Для того, чтобы github выполнил `post`\-запрос, ему нужно будет авторизироваться в вашей базе тестера. Существует несколько вариантов авторизации, но в рамках данного раздела будет рассмотрен наиболее простой, с использованием отдельной папки с публикацией и настройками `vrd`\-файла.

Пример такой настройки в картинках для `IIS`:

![](/img/2019_12_02_21_25_253.png)

![](/img/2019_12_02_21_26_035.png)

Таким образом, мы создаем отдельную публикацию, исключительно для сервиса `hook` с прописанными пользователем и паролем. Обратите внимание, что мы отключили при этом доступ в саму информационную базу, `enable=”false”`.

Сервер, обслуживающий внешние запросы не обязательно должен быть тем же сервером, который и будет фактически запускать процессы тестирования. Логика обработки запросов может формировать задания на тестирование для определенных серверов.

### Создание сценария (тест-метода) который будет отвечать на уведомления github-а

После того, как в github добавлен `webhook`, и на стороне тестера опубликован сервис, осталось определить логику обработки этих уведомлений.

Для этого, в тестере нужно создать сценарий-метод и указать его в качестве обработчика, обслуживающего `post`\-запросы.

Вот как это реализовано в демо-базе тестера:

![](/img/2019_12_02_21_41_239.png)

Затем, нужно созданный и помещенный внутрь тестера сценарий, указать в качестве обработчика, как показано на картинке:

![](/img/2019_12_02_21_36_416.png)

![](/img/2019_12_02_21_37_508.png)

Для полноты иллюстрации, приведу полный код сценария `Тестер.ОбработчикВебЗапроса` (последнюю версию теста всегда можно найти в публичном репозитории общих тестов [https://github.com/grumagargler/CommonTests](https://github.com/grumagargler/CommonTests))

    // Тест-метод обработки внешних запросов системы управления
    // версиями: github.com, gitlab.com и другие. Этот сценарий установлен
    // в настройках системы как ответственный за обслуживание запросов
    // веб-сервиса Hook.
    
    // Получаем данные внешнего запроса
    данные = данныеЗапроса ( _ );
    
    // В зависимости от идентификатора тестируемой конфигурации
    // организуем логику тестирования
    проект = данные.Приложение;
    если ( проект = "ERP2" ) тогда
    	// Создаем задание для запуска тестов ERP2.
    	// Подробнее о работе метода СоздатьЗадание см. в документации
    	СоздатьЗадание ( "Тестер", "ЗапуститьERP2тесты", проект, , , данные.Комментарий );
    иначе
    	вызватьисключение "Запрос на обновление " + проект + " не был обработан";
    конецесли;
    
    &НаСервере
    Функция данныеЗапроса ( Параметры )
    
    	// Получим внешний запрос в виде структуры
    	п = Conversion.FromJSON ( Параметры.Body );
    	данные = новый Структура ( "Сервис, Приложение, Комментарий" );
    	сервис = кто ( Параметры );
    	данные.Сервис = сервис;
    	// В зависимости от используемого сервиса, делаем разбор переданных параметров
    	если ( сервис = gitlab () ) тогда
    		// gitlab в самом запросе содержит информацию о помещениях.
    		// Детали см. в документации:
    		// https://gitlab.com/help/user/project/integrations/webhooks
    		заметки = новый Массив ();
    		для каждого помещение из п.commits цикл
    			заметки.Добавить ( помещение.author.name + ": " );
    			для каждого запись из СтрРазделить ( помещение.message, Chars.LF ) цикл
    				если ( не ПустаяСтрока ( запись ) ) тогда
    					заметки.Добавить ( запись + ";" );
    				конецесли;
    			конеццикла;
    		конеццикла;
    		данные.Комментарий = СтрСоединить ( заметки );
    		данные.Приложение = п.project.name;
    	иначеесли ( сервис = github () ) тогда
    		// github не передает в запросе информацию о помещениях.
    		// для их получения нужно использовать web-api (выходит за рамки этого сценария)
    		// Детали см. в документации:
    		// https://developer.github.com/webhooks/
    		данные.Комментарий = п.sender.login;
    		данные.Приложение = п.repository.name;
    	конецесли;
    	возврат данные; 
    
    КонецФункции
    
    &НаСервере
    Функция github ()
    
    	возврат "github";
    
    КонецФункции
    
    &НаСервере
    Функция gitlab ()
    
    	возврат "gitlab";
    
    КонецФункции
    
    &НаСервере
    Функция кто ( Параметры )
    
    	заголовок = Параметры.Headers;
    	// По переданному заголовку определяем источник запроса
    	если ( заголовок.Получить ( "X-GitHub-Event" ) <> неопределено ) тогда
    		возврат github ();
    	иначеесли ( заголовок.Получить ( "X-Gitlab-Event" ) <> неопределено ) тогда
    		возврат gitlab ();
    	иначе
    		вызватьисключение "Неопознанный запрос на обновление: " + Conversion.ToJSON ( Параметры.Body );
    	конецесли;
    
    КонецФункции

### Тестирование работы webhook-а

Для тестирования отработки уведомлений, можно использовать встроенные в github/gitlab средства отсылки тестовых запросов, например:

![](/img/2019_12_03_00_51_341.png)
